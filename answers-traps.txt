1.	哪个寄存器包含函数的参数？例如，在main调用printf时，哪个寄存器保存了数字13？
在RISC-V的调用约定中，函数的前八个参数依次保存在a0到a7寄存器中。因此，在main调用printf时，a0寄存器中保存的是第一个参数，a1保存的是第二个参数，以此类推。具体到问题中的数字13，若它是printf的第一个参数，它将会保存在a0寄存器中。
2.	在main的汇编代码中，函数f的调用在哪里？g的调用在哪里？（提示：编译器可能会内联函数。）
为了找到f和g的调用位置，你需要查看call.asm文件的内容。如果编译器内联了这些函数（即将函数的代码直接插入调用它们的地方），那么你可能不会看到显式的调用指令，如jal（跳转并链接）指令，而是直接看到内联后的代码。在内联的情况下，函数体的代码将直接出现在main的代码中，而不是通过显式的函数调用。
3.	printf函数位于什么地址？
printf函数的地址可以通过查看call.asm中的符号表或在函数调用时查看加载地址来确定。通常情况下，printf的地址会在全局符号表中列出，你可以在文件的开始部分找到相关信息。
4.	在main中执行jalr到printf之后，寄存器ra中的值是什么？
在执行jalr指令时，ra（返回地址寄存器）会保存下一条指令的地址，也就是函数调用返回后要继续执行的地址。因此，在main中jalr到printf之后，ra中保存的是printf调用返回后main函数中紧接着的指令地址。
5.	运行以下代码会输出什么？
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);

代码的输出是：He110 Wo!rld。
解释：57616在十六进制中是e110，对应的ASCII字符是"e110"。&i指向i的地址，i的值是0x00646c72。在小端存储中，这个值对应的是"rld"（ASCII值分别为72, 6c, 64）。因此，%s会输出"rld"，使得整体输出为"He110 Wo!rld"。
6.	如果RISC-V是大端模式，为了获得相同的输出，你需要如何设置i？你需要改变i的值吗？
如果RISC-V是大端模式，为了获得相同的输出，你需要将i的值设置为0x726c6400。在大端模式下，字节的高位保存在低地址处，因此设置成这个值可以保证输出和小端模式下的一致。
7.	在以下代码中，y=之后会打印什么？为什么会这样？
printf("x=%d y=%d", 3);

输出中y=之后会打印一个未定义的值。原因是printf的格式字符串要求两个整数参数（一个用于x，一个用于y），但实际上只传递了一个参数3。由于没有提供第二个参数，printf在访问第二个未定义参数时会读取栈上随机的内容，这导致了y=后打印出一个未定义的值。这种情况下的行为是未定义的，并且会因编译器和运行环境不同而有所变化。

